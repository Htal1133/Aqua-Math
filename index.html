<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Aqua Math</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg1: #0c1224;
      --bg2: #16233f;
      --panel: rgba(255,255,255,0.08);
      --panel-stroke: rgba(255,255,255,0.15);
      --text: #f5f7ff;
      --accent: #4fd1c5;
      --gold1: #ffdf6b;
      --gold2: #ffa928;
      --blue1: #87b2ff;
      --blue2: #4a70ff;
      --danger: #ff5b6b;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; height: 100%; background: radial-gradient(1200px 800px at 50% 0% , var(--bg2), var(--bg1));
      color: var(--text); font-family: "Poppins", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: grid; place-items: center; user-select: none;
    }
    canvas {
      display: block;
      width: 1280px;
      height: 720px;
      background: transparent;
      border-radius: 18px;
      box-shadow:
        0 20px 60px rgba(0,0,0,0.6),
        inset 0 0 0 1px rgba(255,255,255,0.06);
      image-rendering: auto;
      max-width: 95vw;
      max-height: 95vh;
    }
    @media (max-width: 1300px) {
      canvas { width: 95vw; height: calc(95vw * 9 / 16); }
    }
    @media (max-height: 800px) {
      canvas { height: 95vh; width: calc(95vh * 16 / 9); }
    }
    /* Modo tela cheia */
    :fullscreen canvas, :-webkit-full-screen canvas, :-moz-full-screen canvas {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      border-radius: 0;
      box-shadow: none;
    }
  </style>
</head>
<body>
<canvas id="game" width="1280" height="720"></canvas>

<script>
// ===================== Config e Utils =====================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const BASE_W = 1280, BASE_H = 720;
let dpr = Math.min(2, window.devicePixelRatio || 1); // limitar para performance

function setupDPR() {
  const cssW = canvas.clientWidth || BASE_W;
  const cssH = canvas.clientHeight || BASE_H;
  dpr = Math.min(2, window.devicePixelRatio || 1);
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // Removido render imediato para evitar acessar variáveis antes de inicializar
  // O redesenho ocorrerá no próximo frame do loop principal

  console.log("Canvas redimensionado:", canvas.width, "x", canvas.height);
}

// Configuração inicial
setupDPR();

// Adicionar eventos de redimensionamento
window.addEventListener('resize', setupDPR);
window.addEventListener('fullscreenchange', setupDPR);
window.addEventListener('webkitfullscreenchange', setupDPR);
window.addEventListener('mozfullscreenchange', setupDPR);
window.addEventListener('MSFullscreenChange', setupDPR);

const W = () => (canvas.clientWidth || BASE_W);
const H = () => (canvas.clientHeight || BASE_H);

const rand = (a,b) => a + Math.random()*(b-a);
const clamp = (v,a,b) => Math.max(a, Math.min(b,v));

// Velocidade do navio (AJUSTES DESEJADOS)
const SHIP_ACCEL = 1000; // aceleração mais forte (antes 600)
const SHIP_DAMP  = 0.95; // menos amortecimento (antes 0.90)
const SHIP_VMAX  = 900;  // limite de velocidade

function roundedRectPath(x,y,w,h,r){
  const rr = Math.min(r, w*0.5, h*0.5);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

function drawCard(x,y,w,h,alpha=0.12){
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.fillStyle = `rgba(255,255,255,${alpha})`;
  roundedRectPath(x,y,w,h,12);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();
}

function collide(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

// ===================== Assets (com fallback) =====================
const shipImg = new Image();
shipImg.src = 'barco_sprites.png';
let shipReady = false; shipImg.onload = () => shipReady = true;

const rockImg = new Image();
rockImg.src = 'pedra.png';
let rockReady = false; rockImg.onload = () => rockReady = true;

const logoImg = new Image();
logoImg.src = 'logo.png';
let logoReady = false; logoImg.onload = () => logoReady = true;

const logo2Img = new Image();
logo2Img.src = 'logo2.png';
let logo2Ready = false; logo2Img.onload = () => logo2Ready = true;

// ===================== Estado do jogo =====================
let state = {
  mode: 'menu',
  score: 0,
  shipX: BASE_W / 2,
  shipNum: 1,
  targetNum: 2, // Próximo número a ser coletado nos níveis 3 e 4
  objs: [],
  spawnTimer: 0,
  speed: 1,
  msg: '',
  playerName: '',
  menuIndex: 0
};

// ===================== Tabela de Classificação =====================
// Função para carregar a tabela de classificação do localStorage
function loadLeaderboard() {
  const leaderboardData = localStorage.getItem('navioBoardLevel1');
  return leaderboardData ? JSON.parse(leaderboardData) : [];
}

// Função para salvar a tabela de classificação no localStorage
function saveLeaderboard(leaderboard) {
  localStorage.setItem('navioBoardLevel1', JSON.stringify(leaderboard));
}

// Função para adicionar uma nova pontuação à tabela de classificação
function addScoreToLeaderboard(name, score) {
  const leaderboard = loadLeaderboard();
  
  // Adicionar a nova pontuação
  leaderboard.push({ name, score, date: new Date().toLocaleDateString() });
  
  // Ordenar por pontuação (maior para menor)
  leaderboard.sort((a, b) => b.score - a.score);
  
  // Manter apenas as 20 melhores pontuações
  if (leaderboard.length > 20) {
    leaderboard.length = 20;
  }
  
  // Salvar a tabela atualizada
  saveLeaderboard(leaderboard);
  
  return leaderboard;
}
let keys = new Set();
let shipVX = 0;
let level = 1;

// Efeitos
let tGlobal = 0;
let shake = 0;
const wakeParticles = [];
const fxParticles = [];
const MAX_PARTICLES = 220;

// ===================== Controles =====================
// Adicionar evento de clique para os botões
canvas.addEventListener('click', function(e) {
  if (state.mode !== 'menu') return;
  
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const clickX = (e.clientX - rect.left) * scaleX;
  const clickY = (e.clientY - rect.top) * scaleY;
  
  // Usar tamanho atual do canvas para bater com o que foi desenhado
  const w = canvas.width / dpr, h = canvas.height / dpr;
  const cw = Math.min(700, w*0.9), ch = 380;
  const cx = (w - cw)/2, cy = (h - ch)/2;
  
  // Botões para os níveis
  const buttonW = 600, buttonH = 56;
  const buttonX = (w - buttonW) / 2;
  
  // Verificar se clicou em algum botão (alinhado com starts do drawMenu)
  if (clickX >= buttonX && clickX <= buttonX + buttonW) {
    const starts = [150, 210, 270, 330, 390];
    const labelsTopOffset = -28; // metade da cápsula
    // Nível 1
    if (clickY >= cy + starts[0] + labelsTopOffset && clickY <= cy + starts[0] + labelsTopOffset + buttonH) {
      state.mode = 'enterName';
      state.playerName = '';
    }
    // Nível 2
    else if (clickY >= cy + starts[1] + labelsTopOffset && clickY <= cy + starts[1] + labelsTopOffset + buttonH) {
      startLevel(2);
    }
    // Nível 3
    else if (clickY >= cy + starts[2] + labelsTopOffset && clickY <= cy + starts[2] + labelsTopOffset + buttonH) {
      startLevel(3);
    }
    // Nível 4
    else if (clickY >= cy + starts[3] + labelsTopOffset && clickY <= cy + starts[3] + labelsTopOffset + buttonH) {
      startLevel(4);
    }
    // Ajuda
    else if (clickY >= cy + starts[4] + labelsTopOffset && clickY <= cy + starts[4] + labelsTopOffset + buttonH) {
      state.mode = 'help';
    }
  }
});

// Função para alternar modo tela cheia
function toggleFullScreen() {
  if (!document.fullscreenElement &&    // método padrão
      !document.mozFullScreenElement && // Firefox
      !document.webkitFullscreenElement && // Chrome, Safari e Opera
      !document.msFullscreenElement) {  // IE/Edge
    // Entrar no modo tela cheia
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.mozRequestFullScreen) { // Firefox
      document.documentElement.mozRequestFullScreen();
    } else if (document.documentElement.webkitRequestFullscreen) { // Chrome, Safari e Opera
      document.documentElement.webkitRequestFullscreen();
    } else if (document.documentElement.msRequestFullscreen) { // IE/Edge
      document.documentElement.msRequestFullscreen();
    }
  } else {
    // Sair do modo tela cheia
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) { // Firefox
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) { // Chrome, Safari e Opera
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { // IE/Edge
      document.msExitFullscreen();
    }
  }
}

window.addEventListener('keydown', e => {
  console.log("Tecla pressionada:", e.key);
  
  // Tecla F para alternar modo tela cheia
  if (e.key === 'f' || e.key === 'F') {
    toggleFullScreen();
    return;
  }
  
  if (e.key === 'Escape') { 
    if (state.mode === 'enterName') {
      state.mode = 'menu';
    } else if (state.mode === 'leaderboard') {
      state.mode = 'menu';
    } else {
      state.mode = 'menu'; 
      resetGame(); 
    }
  }
  
  if (state.mode === 'menu') {
    // Navegação: Esquerda/Direita para trocar opção; Espaço para selecionar
    const options = ['enterName', 'level2', 'level3', 'level4', 'help'];
    if (e.key === 'ArrowLeft') {
      state.menuIndex = (state.menuIndex + options.length - 1) % options.length;
      return;
    }
    if (e.key === 'ArrowRight') {
      state.menuIndex = (state.menuIndex + 1) % options.length;
      return;
    }
    if (e.key === ' ') { // Espaço seleciona
      const choice = options[state.menuIndex];
      if (choice === 'enterName') { state.mode = 'enterName'; state.playerName = ''; }
      else if (choice === 'level2') startLevel(2);
      else if (choice === 'level3') startLevel(3);
      else if (choice === 'level4') startLevel(4);
      else if (choice === 'help') state.mode = 'help';
      return;
    }
    // Atalhos diretos continuam
    if (e.key === 'h' || e.key === 'H') { state.mode = 'help'; return; }
    if (e.key === '1' || e.key === 'Numpad1' || e.key === 'Digit1') { state.mode = 'enterName'; state.playerName = ''; }
    else if (e.key === '2' || e.key === 'Numpad2' || e.key === 'Digit2') startLevel(2);
    else if (e.key === '3' || e.key === 'Numpad3' || e.key === 'Digit3') startLevel(3);
    else if (e.key === '4' || e.key === 'Numpad4' || e.key === 'Digit4') startLevel(4);
  }

  // Rolagem na tela de leaderboard
  if (state.mode === 'leaderboard') {
    const lb = loadLeaderboard();
    const visibleRows = 8;
    state.leaderboardOffset = state.leaderboardOffset || 0;
    if (e.key === 'ArrowDown') {
      if (state.leaderboardOffset < Math.max(0, lb.length - visibleRows)) {
        state.leaderboardOffset++;
      }
      return;
    }
    if (e.key === 'ArrowUp') {
      if (state.leaderboardOffset > 0) {
        state.leaderboardOffset--;
      }
      return;
    }
  }
  
  // Adicionar a tecla ao conjunto de teclas pressionadas
  keys.add(e.key);
});

// Adicionar evento para capturar entrada de texto para o nome
window.addEventListener('keypress', e => {
  if (state.mode === 'enterName') {
    // Se pressionar Enter e o nome não estiver vazio, inicia o jogo
    if (e.key === 'Enter' && state.playerName.trim().length > 0) {
      startLevel(1);
    } 
    // Adiciona caracteres ao nome (limitado a 15 caracteres)
    else if (e.key !== 'Enter' && state.playerName.length < 15) {
      state.playerName += e.key;
    }
  }
});

// Adicionar evento para permitir apagar caracteres do nome
window.addEventListener('keydown', e => {
  if (state.mode === 'enterName' && e.key === 'Backspace') {
    state.playerName = state.playerName.slice(0, -1);
    e.preventDefault(); // Previne que a página volte
  }
});
window.addEventListener('keyup', e => keys.delete(e.key));

// ===================== Fluxo de jogo =====================
function resetGame() {
  state.score = 0;
  state.shipX = BASE_W / 2;
  state.objs = [];
  state.spawnTimer = 0;
  state.speed = 1;
  state.msg = '';
  state.targetNum = 2; // Reiniciar o próximo número alvo
  state.l2Remaining = 0; // progresso do nível 2 (coletas restantes)
  shipVX = 0;
  shake = 0;
  wakeParticles.length = 0;
  fxParticles.length = 0;
}

function startLevel(lv) {
  resetGame();
  level = lv;
  if (level === 1) state.mode = 'level1';
  if (level === 2) { 
    state.mode = 'level2'; 
    // Nível 2: o alvo é o número que já está no barco; agora precisa coletar 3 vezes
    state.shipNum = Math.floor(Math.random() * 10) + 1; // 1..10
    state.targetNum = state.shipNum;
    state.l2Remaining = 3; // colete 3 vezes o número correto
  }
  if (level === 3) { 
    state.mode = 'level3'; 
    // Nível 3: sequência positiva de 1 até 10
    state.shipNum = 1; 
    state.targetNum = 2; 
  }
  if (level === 4) { 
    state.mode = 'level4'; 
    // Nível 4: sequência negativa de -10 até 5
    state.shipNum = -10; 
    state.targetNum = -9; 
  }
}

function gameOver(msg) {
  // Se for o nível 1, salvar a pontuação na tabela de classificação
  if (level === 1 && state.playerName && state.playerName.trim().length > 0) {
    addScoreToLeaderboard(state.playerName, state.score);
    state.mode = 'leaderboard';
  } else {
    state.mode = 'gameover';
  }
  
  state.msg = msg || 'Game Over';
  shake = 10;
}

// ===================== Spawners =====================
function spawnRock() {
  state.objs.push({
    type: 'rock',
    x: rand(40, BASE_W-40),
    y: -40,
    vy: rand(100,180),
    rot: rand(-0.2,0.2)
  });
}

function spawnNumber() {
  let val;
  
  if (level === 4) {
    // Nível 4: aumentar a chance de gerar o próximo número na sequência (negativos -10..5)
    if (Math.random() < 0.5) {
      val = state.targetNum; // 50% de chance de ser o número alvo
      console.log(`Gerando número alvo: ${val} para nível 4`);
    } else {
      // 50%: número aleatório entre -10 e 5, diferente do alvo
      do {
        val = Math.floor(Math.random() * 16) - 10; // -10..5
      } while (val === state.targetNum);
      console.log(`Gerando número aleatório: ${val} para nível 4`);
    }
  } else if (level === 3) {
    // Nível 3: gerar números 1..10 com aumento de chance do alvo
    if (Math.random() < 0.5) {
      val = state.targetNum;
    } else {
      do { val = Math.floor(Math.random() * 10) + 1; } while (val === state.targetNum);
    }
  } else if (level === 2) {
    // Nível 2: até vencer, gerar aleatórios 1..10 (inclui 7,8,9,10) e o alvo pode aparecer
    if (Math.random() < 0.5) {
      val = state.targetNum;
    } else {
      do { val = Math.floor(Math.random() * 10) + 1; } while (val === state.targetNum);
    }
  }
  
  state.objs.push({
    type: 'num',
    x: rand(40, BASE_W-40),
    y: -40,
    vy: rand(100,160),
    val,
    rot: rand(-0.15,0.15)
  });
}

// ===================== Partículas =====================
function addWakeParticle(x, y) {
  if (wakeParticles.length > MAX_PARTICLES) wakeParticles.shift();
  wakeParticles.push({
    x, y,
    r: rand(2,4),
    vx: rand(-20,20),
    vy: rand(40,90),
    life: rand(0.6,1.0),
    alpha: 1
  });
}

function addConfetti(x, y, colorA, colorB) {
  const n = 20;
  for (let i=0;i<n;i++){
    if (fxParticles.length > MAX_PARTICLES) fxParticles.shift();
    fxParticles.push({
      x, y,
      r: rand(2,4),
      vx: rand(-160,160),
      vy: rand(-220, -80),
      g: rand(320, 520),
      rot: rand(0, Math.PI*2),
      vr: rand(-6,6),
      color: Math.random()<0.5?colorA:colorB,
      life: rand(0.6,1.0),
      alpha: 1
    });
  }
}

// ===================== Background (ondas) =====================
function drawBackground(dt, w, h) {
  // Fundo todo azul oceano no Nível 1 para reforçar visão de cima do mar
  const isL1 = state.mode === 'level1';

  // Céu removido no nível 1; no demais mantém leve gradiente
  const skyGrad = ctx.createLinearGradient(0,0,0,h);
  if (!isL1) {
    skyGrad.addColorStop(0, '#102041');
    skyGrad.addColorStop(1, '#0b1226');
  } else {
    skyGrad.addColorStop(0, '#0f355f');
    skyGrad.addColorStop(1, '#0a2747');
  }
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0,0,w,h);

  // Água ocupa toda a tela no nível 1; nos demais, mantém horizonte
  const waterTop = isL1 ? 0 : h*0.35;
  const waterGrad = ctx.createLinearGradient(0, waterTop, 0, h);
  if (isL1) {
    waterGrad.addColorStop(0, '#0e6398');
    waterGrad.addColorStop(1, '#09446f');
  } else {
    waterGrad.addColorStop(0, '#143a64');
    waterGrad.addColorStop(1, '#0b2746');
  }
  ctx.fillStyle = waterGrad;
  ctx.fillRect(0, waterTop, w, h-waterTop);

  // Glow do horizonte somente quando não for nível 1
  if (!isL1) {
    const glowY = h*0.55 + Math.sin(tGlobal*0.4)*6;
    const glowGrad = ctx.createRadialGradient(w*0.5, glowY, 10, w*0.5, glowY, w*0.6);
    glowGrad.addColorStop(0, 'rgba(255,255,255,0.08)');
    glowGrad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(0,0,w,h);
  }

  ctx.save();
  ctx.globalAlpha = 0.45;
  // Ondas e esteiras para dar percepção de movimento lateral
  for (let layer=0; layer<4; layer++){
    const amp = (isL1 ? 10 : 8) + layer*5;
    const freq = 0.012 + layer*0.004;
    const speed = 20 + layer*12;
    const yBase = (waterTop + 20 + layer*18) + Math.sin(tGlobal*0.6 + layer)*4;
    ctx.beginPath();
    ctx.moveTo(0, yBase);
    for (let x=0; x<=w; x+=6){
      // leve deslocamento horizontal para parecer correnteza
      const offset = Math.sin(tGlobal*0.5 + layer) * 4;
      const y = yBase + Math.sin(((x+offset)*freq) + (tGlobal*speed*0.05)) * amp;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.lineTo(0, h);
    ctx.closePath();
    const g = ctx.createLinearGradient(0, yBase-amp, 0, h);
    if (isL1) {
      g.addColorStop(0, 'rgba(255,255,255,0.11)');
      g.addColorStop(1, 'rgba(255,255,255,0.00)');
    } else {
      g.addColorStop(0, 'rgba(255,255,255,0.10)');
      g.addColorStop(1, 'rgba(255,255,255,0.00)');
    }
    ctx.fillStyle = g;
    ctx.fill();
  }

  // Linhas de espuma horizontais rápidas no nível 1 para reforçar desvio no mar
  if (isL1) {
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = 'rgba(255,255,255,0.28)';
    ctx.lineWidth = 1.2;
    const bandCount = 6;
    for (let i=0;i<bandCount;i++){
      const y = (h*0.15) + i*(h*0.12) + Math.sin(tGlobal*1.5 + i)*5;
      ctx.beginPath();
      for (let x=0; x<=w; x+=24){
        const yy = y + Math.sin(x*0.04 + tGlobal*2 + i)*2;
        ctx.moveTo(x, yy);
        ctx.lineTo(x+12, yy + Math.sin(x*0.07 + tGlobal*3 + i)*1.5);
      }
      ctx.stroke();
    }
  }

  ctx.restore();
}

// ===================== Loop =====================
let last = performance.now();
function loop(t) {
  const dt = Math.min(0.033, (t - last)/1000);
  last = t;
  tGlobal += dt;

  update(dt);
  render(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ===================== Update =====================
function update(dt) {
  // Usar tamanho atual do canvas para alinhamento correto de colisões
  const w = canvas.width / dpr, h = canvas.height / dpr;

  if (state.mode.startsWith('level')) {
    // Movimento do navio (MAIS RÁPIDO)
    if (keys.has('ArrowLeft')) {
      shipVX -= SHIP_ACCEL * dt;
      console.log("Tecla esquerda pressionada, shipVX =", shipVX);
    }
    if (keys.has('ArrowRight')) {
      shipVX += SHIP_ACCEL * dt;
      console.log("Tecla direita pressionada, shipVX =", shipVX);
    }
    shipVX *= SHIP_DAMP;
    shipVX = clamp(shipVX, -SHIP_VMAX, SHIP_VMAX);

    state.shipX += shipVX * dt;
    state.shipX = clamp(state.shipX, 40, w-40);
    
    // Debug
    if (Math.abs(shipVX) > 0.1) {
      console.log("Barco movendo: shipVX =", shipVX, "shipX =", state.shipX);
    }

    // Spawn
    state.spawnTimer += dt;
    const interval = 1 / state.speed;
    if (state.spawnTimer > interval) {
      state.spawnTimer = 0;
      if (level === 1) spawnRock();
      else spawnNumber();
    }

    // Dificuldade
    state.speed += dt * 0.08;

    // Partículas de rastro
    if (Math.abs(shipVX) > 5 || Math.random() < 0.5) {
      addWakeParticle(state.shipX + rand(-14,14), h-68 + rand(-2,6));
    }

    // Atualizar objetos
    for (let i = state.objs.length-1; i>=0; i--) {
      const o = state.objs[i];
      o.y += o.vy * dt * state.speed;
      if (o.type==='rock') {
        // Caixa de colisão ajustada ao sprite do barco
        const shipW = 44, shipH = 36; // um pouco menor que o sprite de 64x64
        if (collide(state.shipX-shipW/2, h-100, shipW, shipH, o.x-22, o.y-22, 44, 44)) {
          addConfetti(o.x, o.y, 'rgba(255,255,255,0.9)', 'rgba(255,80,90,0.9)');
          gameOver('Bateu na pedra!');
        }
      }
      if (o.type==='num') {
        const shipW = 44, shipH = 36;
        if (collide(state.shipX-shipW/2, h-100, shipW, shipH, o.x-22, o.y-22, 44, 44)) {
          if (level === 2) {
            // Nível 2: pegar exatamente o número que está no barco, agora 3 vezes
            if (o.val === state.targetNum) {
              state.shipNum = o.val;
              state.score += 5;
              state.l2Remaining = Math.max(0, (state.l2Remaining || 0) - 1);
              addConfetti(o.x, o.y, '#ffe58a', '#ffb84d');
              if (state.l2Remaining <= 0) {
                state.mode = 'win';
                state.msg = 'Você venceu!';
              }
            } else {
              addConfetti(o.x, o.y, '#ff7585', '#ff3b57');
              gameOver('Número errado!');
            }
          } else if (level === 3) {
            // Nível 3: sequência positiva de 1..10
            const expected = state.shipNum + 1;
            if (o.val === expected) {
              state.shipNum = o.val;
              state.score += 5;
              addConfetti(o.x, o.y, '#ffe58a', '#ffb84d');
              state.targetNum = state.shipNum + 1;
              if (state.shipNum >= 10) {
                state.mode = 'win';
                state.msg = 'Você venceu!';
              }
            } else {
              addConfetti(o.x, o.y, '#ff7585', '#ff3b57');
              gameOver('Número errado!');
            }
          } else if (level === 4) {
            // Nível 4: sequência negativa de -10..5
            if (o.val === state.targetNum) {
              state.shipNum = o.val;
              state.score += 5;
              addConfetti(o.x, o.y, '#8ec5ff', '#5a8bff');
              state.targetNum = state.shipNum + 1;
              if (state.shipNum >= 5) {
                state.mode = 'win';
                state.msg = 'Você venceu!';
              }
            } else {
              addConfetti(o.x, o.y, '#ff7585', '#ff3b57');
              gameOver('Número errado!');
            }
          }
          state.objs.splice(i,1);
          continue;
        }
      }
      if (o.y > h + 60) {
        if (o.type==='rock' && level===1) state.score++;
        state.objs.splice(i,1);
      }
    }
  }

  // Atualizar partículas
  for (let i=wakeParticles.length-1; i>=0; i--){
    const p = wakeParticles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.alpha -= dt / p.life;
    p.vx *= 0.98;
    if (p.alpha <= 0) wakeParticles.splice(i,1);
  }
  for (let i=fxParticles.length-1; i>=0; i--){
    const p = fxParticles[i];
    p.vy += p.g * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.rot += p.vr * dt;
    p.alpha -= dt / p.life;
    if (p.alpha <= 0 || p.y > BASE_H + 100) fxParticles.splice(i,1);
  }

  shake = Math.max(0, shake - dt*12);
}

// ===================== Render =====================
function render(dt) {
  // Usar o tamanho atual do canvas em pixels CSS para centralizar corretamente
  const w = canvas.width / dpr, h = canvas.height / dpr;

  ctx.save();

  drawBackground(dt, w, h);

  const sx = (Math.random() * 2 - 1) * shake;
  const sy = (Math.random() * 2 - 1) * shake;
  ctx.translate(sx, sy);

  if (state.mode==='menu') {
    // Exibir o barco também no menu
    drawShip(w, h);
    drawMenu(w, h);
    ctx.restore();
    drawOverlayFrame(w, h);
    return;
  }
  if (state.mode==='help') {
    // Exibir o barco também na tela de ajuda
    drawShip(w, h);
    drawHelpScreen(w, h);
    ctx.restore();
    drawOverlayFrame(w, h);
    return;
  }
  
  if (state.mode==='enterName') {
    drawEnterNameScreen(w, h);
    ctx.restore();
    drawOverlayFrame(w, h);
    return;
  }
  
  if (state.mode==='leaderboard') {
    drawLeaderboardScreen(w, h);
    ctx.restore();
    drawOverlayFrame(w, h);
    return;
  }

  // Indicação sutil no nível 1 de que está desviando no mar
  if (state.mode==='level1') {
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.textAlign = 'center';
    ctx.font = '600 14px Poppins, Arial';
    ctx.fillText('Desvie das pedras no mar', w/2, 56);
    ctx.restore();
  }

  for (const o of state.objs) {
    if (o.type==='rock') {
      drawRock(o);
    } else if (o.type==='num') {
      drawNumBox(o);
    }
  }

  drawShip(w, h);

  drawWake();
  drawFX();

  drawHUD();

  if (state.mode==='gameover' || state.mode==='win') {
    drawEndScreen(w, h, state.msg);
  }

  ctx.restore();
  drawOverlayFrame(w, h);
}

// ===================== Desenho de elementos =====================
function drawHelpScreen(w, h) {
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const cw = Math.min(760, w*0.9), ch = 460;
  const cx = (w - cw)/2, cy = (h - ch)/2;
  drawCard(cx, cy, cw, ch, 0.24); // fundo branco translúcido para melhor contraste

  const title = 'Ajuda';
  ctx.font = '900 46px Poppins, Arial';
  const grad = ctx.createLinearGradient(0, cy, 0, cy+ch);
  grad.addColorStop(0, '#9be8df');
  grad.addColorStop(1, '#53d0c5');
  ctx.fillStyle = grad;
  ctx.strokeStyle = 'rgba(0,0,0,0.45)';
  ctx.lineWidth = 6;
  ctx.strokeText(title, w/2, cy + 70);
  ctx.fillText(title, w/2, cy + 70);

  ctx.textAlign = 'left';
  ctx.fillStyle = '#0d142a'; // texto escuro em cima do branco translúcido
  ctx.font = '600 18px Poppins, Arial';

  const lines = [
    'Use as setas ← → para mover o navio.',
    'Tecla ESC volta ao menu.',
    'Tecla F alterna tela cheia.',
    '',
    'Nível 1: Desvie das pedras no mar para fazer pontos.',
    'Nível 2: Pegue o número do barco 3 vezes para vencer.',
    'Nível 3: Colete os números em sequência de 1 até 10 (começa no 1).',
    'Nível 4: Colete números negativos de -10 até 5.',
    '',
    'HUD: O cartão "Alvo" mostra o próximo número a coletar (Níveis 3 e 4).',
    'Pegue sempre o número indicado no "Alvo" para avançar a sequência.'
  ];

  let ty = cy + 120;
  for (const line of lines) {
    ctx.fillText(line, cx + 40, ty);
    ty += 28; // linhas um pouco mais próximas para caber no card
  }

  // Mensagem inferior fora do card para não sobrepor
  ctx.textAlign = 'center';
  ctx.font = '600 16px Poppins, Arial';
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillText('Pressione ESC para voltar', w/2, cy + ch + 32);

  ctx.restore();
}

// ===================== Desenho de elementos =====================
function drawMenu(w, h) {
  const title = 'Aqua Math';
  const sub = 'Use ← → para mover | ESC para voltar | F para tela cheia';
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const cw = Math.min(720, w*0.88), ch = 440; // mais espaço para os itens
  const cx = (w - cw)/2, cy = (h - ch)/2;
  drawCard(cx, cy, cw, ch, 0.24);

  // título com contraste melhor
  const grad = ctx.createLinearGradient(0, cy, 0, cy+ch);
  grad.addColorStop(0, '#9be8df');
  grad.addColorStop(1, '#53d0c5');
  ctx.fillStyle = grad;
  ctx.strokeStyle = 'rgba(0,0,0,0.45)';
  ctx.lineWidth = 6;

  // Logos com placas brancas de fundo para contraste
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.25)';
  ctx.shadowBlur = 8;
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  roundedRectPath(cx + 40, cy + 40, 72, 72, 12);
  ctx.fill();
  roundedRectPath(cx + cw - 112, cy + 40, 72, 72, 12);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();
  if (logoReady) ctx.drawImage(logoImg, cx + 44, cy + 44, 64, 64);
  if (logo2Ready) ctx.drawImage(logo2Img, cx + cw - 108, cy + 44, 64, 64);

  ctx.font = '900 56px Poppins, Arial';
  // Centraliza verticalmente em relação às logos (centro das placas ~ cy+76)
  ctx.strokeText(title, w/2, cy + 76);
  ctx.fillText(title, w/2, cy + 76);

  // Texto base dos itens com mais contraste e espaço
  ctx.font = '600 22px Poppins, Arial';
  ctx.fillStyle = '#0d142a';
  
  // Itens do menu
  const buttonW = 600, buttonH = 56;
  const buttonX = (w - buttonW) / 2;

  const options = [
    {label:'Pressione 1 para Nível 1', desc:'Desvie das pedras no mar'},
    {label:'Pressione 2 para Nível 2', desc:'Pegue o número do barco (3 vezes)'},
    {label:'Pressione 3 para Nível 3', desc:'1 até 10 em sequência (começa no 1)'},
    {label:'Pressione 4 para Nível 4', desc:'Números negativos: -10 até 5'},
    {label:'Ajuda', desc:'Explicação dos níveis'}
  ];

  // espaçamentos maiores
  const starts = [150, 210, 270, 330, 390];

  for (let i=0;i<options.length;i++){
    const y = cy + starts[i];
    const selected = (i === state.menuIndex);

    // cápsula de fundo para cada item (melhor contraste e hit area)
    const capsuleX = w/2 - 340;
    const capsuleW = 680;
    const capsuleH = 52;
    ctx.fillStyle = selected ? 'rgba(255,255,255,0.28)' : 'rgba(255,255,255,0.20)'; // branco translúcido para dar base às logos
    roundedRectPath(capsuleX, y-28, capsuleW, capsuleH, 12);
    ctx.fill();

    // rótulos centralizados dentro da cápsula
    ctx.textAlign = 'center';
    ctx.fillStyle = '#0d142a';
    ctx.font = '600 20px Poppins, Arial';
    ctx.fillText(options[i].label, w/2, y - 4);

    ctx.font = '500 13px Poppins, Arial';
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillText(options[i].desc, w/2, y + 16);
  }

  // Rodapé fora da placa do menu, como solicitado
  ctx.font = '500 16px Poppins, Arial';
  ctx.fillStyle = '#ffffff';
  const footerY = cy + ch + 26; // fora do card e com espaçamento
  ctx.fillText('Use ←/→ para navegar, Espaço para selecionar, F para tela cheia', w/2, footerY);
  
  // Créditos
  ctx.textAlign = 'left';
  ctx.font = '400 12px Poppins, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.fillText('Jogo feito por Lucas Martins e João Carlos Peixoto da 3ª02 - CEEFMTI Prof.ª Maura Abaurre.', 20, h - 20);
  ctx.restore();
}

function drawHUD() {
  ctx.save();
  const pad = 14;
  const cardW = 280, cardH = 74;
  drawCard(18, 18, cardW, cardH, 0.14);

  ctx.fillStyle = '#ffffff';
  ctx.textBaseline = 'top';
  ctx.font = '700 20px Poppins, Arial';
  ctx.fillText(`Score: ${state.score}`, 18+pad, 18+pad);
  ctx.font = '600 16px Poppins, Arial';
  
  // Update level text to include level 4
  let lvlText;
  if (state.mode === 'level1') lvlText = 'Nível 1';
  else if (state.mode === 'level2') lvlText = 'Nível 2';
  else if (state.mode === 'level3') lvlText = 'Nível 3';
  else if (state.mode === 'level4') lvlText = 'Nível 4';
  
  ctx.fillText(lvlText, 18+pad, 18+pad+28);

  if (level > 1) {
    // Create a separate card for the target number
    const targetCardW = 140, targetCardH = 74;
    drawCard(cardW + 40, 18, targetCardW, targetCardH, 0.14);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '600 16px Poppins, Arial';
    
    if (level === 2) {
      // Nível 2: mostrar alvo e progresso de coletas restantes
      ctx.fillText(`Alvo:`, cardW + 40 + pad, 18+pad);
      
      ctx.font = '700 32px Poppins, Arial';
      ctx.fillText(`${state.targetNum}`, cardW + 40 + pad + 30, 18+pad+32);

      // Cartão de progresso L2
      const progressCardW = 180, progressCardH = 74;
      drawCard(cardW + 40 + targetCardW + 20, 18, progressCardW, progressCardH, 0.14);
      ctx.fillStyle = '#ffffff';
      ctx.font = '600 16px Poppins, Arial';
      ctx.fillText(`Restantes:`, cardW + 40 + targetCardW + 20 + pad, 18+pad);
      ctx.font = '700 20px Poppins, Arial';
      const rem = state.l2Remaining || 0;
      ctx.fillText(`${rem} / 3`, cardW + 40 + targetCardW + 20 + pad + 30, 18+pad+32);
    } 
    else if (level === 3 || level === 4) {
      // Níveis 3 e 4: Mostrar o próximo número na sequência
      ctx.fillText(`Próximo:`, cardW + 40 + pad, 18+pad);
      
      ctx.font = '700 32px Poppins, Arial';
      ctx.fillText(`${state.targetNum}`, cardW + 40 + pad + 30, 18+pad+32);
      
      // Mostrar o número atual e o objetivo
      const progressCardW = 180, progressCardH = 74;
      drawCard(cardW + 40 + targetCardW + 20, 18, progressCardW, progressCardH, 0.14);
      
      ctx.fillStyle = '#ffffff';
      ctx.font = '600 16px Poppins, Arial';
      ctx.fillText(`Progresso:`, cardW + 40 + targetCardW + 20 + pad, 18+pad);
      
      ctx.font = '700 20px Poppins, Arial';
      if (level === 3) {
        ctx.fillText(`${state.shipNum} → 10`, cardW + 40 + targetCardW + 20 + pad + 30, 18+pad+32);
      } else {
        ctx.fillText(`${state.shipNum} → 5`, cardW + 40 + targetCardW + 20 + pad + 30, 18+pad+32);
      }
    }
    // Exibir número atual do barco (para não duplicar com "Próximo")
    const num = state.shipNum;
    const g = ctx.createLinearGradient(0,0,0,40);
    if (num >= 0) { g.addColorStop(0, '#ffe58a'); g.addColorStop(1, '#ffb84d'); }
    else { g.addColorStop(0, '#8ec5ff'); g.addColorStop(1, '#5a8bff'); }
    ctx.fillStyle = g;
    ctx.font = '700 20px Poppins, Arial';
    ctx.fillText(`Número: ${num}`, 18+pad+120, 18+pad+28);
  }
  ctx.restore();
}

function drawEndScreen(w, h, msg) {
  ctx.save();
  const cw = Math.min(560, w*0.9), ch = 200;
  const cx = (w - cw)/2, cy = (h - ch)/2;
  drawCard(cx, cy, cw, ch, 0.18);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = '900 42px Poppins, Arial';
  ctx.fillStyle = state.mode==='win' ? '#7af0d8' : '#ff8fa0';
  ctx.fillText(msg, w/2, cy+70);

  ctx.font = '600 18px Poppins, Arial';
  ctx.fillStyle = '#eaf0ff';
  ctx.fillText('Pressione ESC para voltar ao menu', w/2, cy+120);
  ctx.restore();
}

function drawOverlayFrame(w, h) {
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0, 'rgba(255,255,255,0.10)');
  g.addColorStop(1, 'rgba(255,255,255,0.02)');
  ctx.strokeStyle = g;
  ctx.lineWidth = 2;
  roundedRectPath(2,2,w-4,h-4,16);
  ctx.stroke();
}

function drawRock(o) {
  ctx.save();
  ctx.translate(o.x, o.y);
  ctx.rotate(o.rot);

  if (rockReady) {
    ctx.drawImage(rockImg, -24, -24, 48, 48);
  } else {
    const g = ctx.createLinearGradient(-24,-24, 24,24);
    g.addColorStop(0, '#7d7d7d');
    g.addColorStop(1, '#505050');
    ctx.fillStyle = g;
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-18,-12);
    ctx.lineTo(-8,-20);
    ctx.lineTo(10,-18);
    ctx.lineTo(20,-6);
    ctx.lineTo(14,10);
    ctx.lineTo(-6,18);
    ctx.lineTo(-22,4);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath();
    ctx.ellipse(-4,-8,12,6,0,0,Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

function drawNumBox(o) {
  ctx.save();
  ctx.translate(o.x, o.y);
  ctx.rotate(o.rot);

  const size = 40;
  ctx.shadowColor = 'rgba(0,0,0,0.4)';
  ctx.shadowBlur = 10;
  const g = ctx.createLinearGradient(0,-size,0,size);
  if (o.val >= 0) { g.addColorStop(0, '#ffe58a'); g.addColorStop(1, '#ffb84d'); }
  else { g.addColorStop(0, '#8ec5ff'); g.addColorStop(1, '#5a8bff'); }
  ctx.fillStyle = g;
  roundedRectPath(-size/2, -size/2, size, size, 10);
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.fillStyle = '#111';
  ctx.font = '700 20px Poppins, Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(o.val, 0, 1);
  ctx.restore();
}

function drawShip(w, h) {
  ctx.save();
  const bob = Math.sin(tGlobal*6 + shipVX*0.02) * 2;
  const frame = shipVX < -20 ? 0 : (shipVX > 20 ? 2 : 1);
  const sx = state.shipX - 32, sy = h - 102 + bob;

  ctx.globalAlpha = 0.25;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(state.shipX, h-60, 26, 10, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;

  if (shipReady) {
    ctx.drawImage(shipImg, frame*64, 0, 64, 64, sx, sy, 64, 64);
  } else {
    ctx.save();
    ctx.translate(state.shipX, h-70 + bob);
    ctx.rotate(shipVX * 0.0008);
    const hull = ctx.createLinearGradient(-30,-20,30,20);
    hull.addColorStop(0, '#9be0d7');
    hull.addColorStop(1, '#58c7bc');
    ctx.fillStyle = hull;
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-30,10);
    ctx.lineTo(30,10);
    ctx.quadraticCurveTo(18,22,0,28);
    ctx.quadraticCurveTo(-18,22,-30,10);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#ffffff';
    roundedRectPath(-12, -10, 24, 18, 4);
    ctx.fill();
    ctx.restore();
  }

  if (Math.random() < 0.4) addWakeParticle(state.shipX + rand(-10,10), h-64 + rand(-4,4));
  ctx.restore();
}

function drawWake() {
  ctx.save();
  for (const p of wakeParticles) {
    ctx.globalAlpha = Math.max(0, p.alpha) * 0.7;
    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r*2);
    g.addColorStop(0, 'rgba(255,255,255,0.7)');
    g.addColorStop(1, 'rgba(255,255,255,0.0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r*2, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

function drawFX() {
  ctx.save();
  for (const p of fxParticles) {
    ctx.globalAlpha = Math.max(0, p.alpha);
    ctx.fillStyle = p.color;
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rot);
    roundedRectPath(-p.r, -p.r, p.r*2, p.r*2, 2);
    ctx.fill();
    ctx.restore();
  }
  ctx.restore();
}

function drawEnterNameScreen(w, h) {
  const title = 'Digite seu nome';
  const sub = 'Pressione ENTER para jogar | ESC para voltar';
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const cw = Math.min(680, w*0.9), ch = 280;
  const cx = (w - cw)/2, cy = (h - ch)/2;
  drawCard(cx, cy, cw, ch, 0.14);

  const grad = ctx.createLinearGradient(0, cy, 0, cy+ch);
  grad.addColorStop(0, '#9be8df');
  grad.addColorStop(1, '#53d0c5');
  ctx.fillStyle = grad;
  ctx.strokeStyle = 'rgba(0,0,0,0.35)';
  ctx.lineWidth = 6;

  ctx.font = '900 48px Poppins, Arial';
  ctx.strokeText(title, w/2, cy + 80);
  ctx.fillText(title, w/2, cy + 80);

  // Campo de entrada de nome
  const inputW = 300, inputH = 50;
  const inputX = (w - inputW) / 2;
  const inputY = cy + 140;
  
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.lineWidth = 2;
  roundedRectPath(inputX, inputY, inputW, inputH, 8);
  ctx.fill();
  ctx.stroke();
  
  // Texto do nome
  ctx.fillStyle = '#333';
  ctx.font = '600 24px Poppins, Arial';
  ctx.textAlign = 'left';
  ctx.fillText(state.playerName + (Math.floor(Date.now()/500) % 2 === 0 ? '|' : ''), inputX + 10, inputY + inputH/2);
  
  // Instruções
  ctx.textAlign = 'center';
  ctx.font = '500 16px Poppins, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.fillText(sub, w/2, cy + ch - 20);
  ctx.restore();
}

function drawLeaderboardScreen(w, h) {
  const title = 'Tabela de Classificação';
  const sub = 'Pressione ESC para voltar ao menu';
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const cw = Math.min(680, w*0.9), ch = 420; // ligeiramente maior para acomodar linhas com margem
  const cx = (w - cw)/2, cy = (h - ch)/2;
  drawCard(cx, cy, cw, ch, 0.14);

  const grad = ctx.createLinearGradient(0, cy, 0, cy+ch);
  grad.addColorStop(0, '#9be8df');
  grad.addColorStop(1, '#53d0c5');
  ctx.fillStyle = grad;
  ctx.strokeStyle = 'rgba(0,0,0,0.35)';
  ctx.lineWidth = 6;

  ctx.font = '900 48px Poppins, Arial';
  ctx.strokeText(title, w/2, cy + 60);
  ctx.fillText(title, w/2, cy + 60);

  // Sua pontuação atual
  ctx.font = '700 24px Poppins, Arial';
  ctx.fillStyle = '#fff';
  ctx.fillText(`Sua pontuação: ${state.score}`, w/2, cy + 110);
  
  // Carregar a tabela de classificação
  const leaderboard = loadLeaderboard();
  
  // Desenhar a tabela (com rolagem)
  const tableW = cw - 80;
  const tableX = cx + 40;
  const tableY = cy + 146;
  const rowH = 30;
  const visibleRows = 8;
  state.leaderboardOffset = state.leaderboardOffset || 0;
  
  // Cabeçalho da tabela
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  roundedRectPath(tableX, tableY, tableW, rowH, 8);
  ctx.fill();
  
  ctx.fillStyle = '#333';
  ctx.font = '700 18px Poppins, Arial';
  ctx.textAlign = 'left';
  ctx.fillText('Pos.', tableX + 20, tableY + rowH/2);
  ctx.fillText('Nome', tableX + 80, tableY + rowH/2);
  ctx.textAlign = 'right';
  ctx.fillText('Pontuação', tableX + tableW - 140, tableY + rowH/2);
  ctx.fillText('Data', tableX + tableW - 20, tableY + rowH/2);
  
  // Linhas da tabela com offset
  const start = state.leaderboardOffset;
  const end = Math.min(start + visibleRows, leaderboard.length);
  for (let i = start; i < end; i++) {
    const entry = leaderboard[i];
    const visIndex = i - start; // índice visível 0..visibleRows-1
    const rowY = tableY + rowH * (visIndex + 1) + 5;
    
    // Destacar a linha do jogador atual
    if (entry.name === state.playerName && entry.score === state.score) {
      ctx.fillStyle = 'rgba(255,255,100,0.3)';
      roundedRectPath(tableX, rowY, tableW, rowH, 4);
      ctx.fill();
    }
    
    ctx.fillStyle = '#fff';
    ctx.font = '600 16px Poppins, Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`${i+1}.`, tableX + 20, rowY + rowH/2);
    ctx.fillText(entry.name, tableX + 80, rowY + rowH/2);
    ctx.textAlign = 'right';
    ctx.fillText(`${entry.score}`, tableX + tableW - 140, rowY + rowH/2);
    ctx.fillText(entry.date, tableX + tableW - 20, rowY + rowH/2);
  }
  
  // Dica de rolagem bem fora do card
  ctx.textAlign = 'center';
  ctx.font = '500 14px Poppins, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  if (leaderboard.length > visibleRows) {
    ctx.fillText('Use ↑/↓ para navegar na lista', w/2, cy + ch + 16);
  }

  // Instruções (ESC) mais abaixo ainda
  ctx.textAlign = 'center';
  ctx.font = '500 16px Poppins, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.fillText(sub, w/2, cy + ch + 38);
  ctx.restore();
}

// O jogo já tem um loop de jogo definido acima, não precisamos de outro
</script>
</body>
</html>
