<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Jogo do Navio — Edição Bonita</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg1: #0c1224;
      --bg2: #16233f;
      --panel: rgba(255,255,255,0.08);
      --panel-stroke: rgba(255,255,255,0.15);
      --text: #f5f7ff;
      --accent: #4fd1c5;
      --gold1: #ffdf6b;
      --gold2: #ffa928;
      --blue1: #87b2ff;
      --blue2: #4a70ff;
      --danger: #ff5b6b;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; height: 100%; background: radial-gradient(1200px 800px at 50% 0% , var(--bg2), var(--bg1));
      color: var(--text); font-family: "Poppins", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: grid; place-items: center; user-select: none;
    }
    canvas {
      display: block;
      width: 1280px;
      height: 720px;
      background: transparent;
      border-radius: 18px;
      box-shadow:
        0 20px 60px rgba(0,0,0,0.6),
        inset 0 0 0 1px rgba(255,255,255,0.06);
      image-rendering: auto;
      max-width: 95vw;
      max-height: 95vh;
    }
    @media (max-width: 1300px) {
      canvas { width: 95vw; height: calc(95vw * 9 / 16); }
    }
    @media (max-height: 800px) {
      canvas { height: 95vh; width: calc(95vh * 16 / 9); }
    }
    /* Modo tela cheia */
    :fullscreen canvas, :-webkit-full-screen canvas, :-moz-full-screen canvas {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      border-radius: 0;
      box-shadow: none;
    }
  </style>
</head>
<body>
<canvas id="game" width="1280" height="720"></canvas>

<script>
// ===================== Config e Utils =====================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const BASE_W = 1280, BASE_H = 720;
let dpr = Math.min(2, window.devicePixelRatio || 1); // limitar para performance

function setupDPR() {
  const cssW = canvas.clientWidth || BASE_W;
  const cssH = canvas.clientHeight || BASE_H;
  dpr = Math.min(2, window.devicePixelRatio || 1);
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  
  // Forçar redesenho imediato
  if (typeof render === 'function') {
    render(0);
  }
  
  console.log("Canvas redimensionado:", canvas.width, "x", canvas.height);
}

// Configuração inicial
setupDPR();

// Adicionar eventos de redimensionamento
window.addEventListener('resize', setupDPR);
window.addEventListener('fullscreenchange', setupDPR);
window.addEventListener('webkitfullscreenchange', setupDPR);
window.addEventListener('mozfullscreenchange', setupDPR);
window.addEventListener('MSFullscreenChange', setupDPR);

const W = () => (canvas.clientWidth || BASE_W);
const H = () => (canvas.clientHeight || BASE_H);

const rand = (a,b) => a + Math.random()*(b-a);
const clamp = (v,a,b) => Math.max(a, Math.min(b,v));

// Velocidade do navio (AJUSTES DESEJADOS)
const SHIP_ACCEL = 1000; // aceleração mais forte (antes 600)
const SHIP_DAMP  = 0.95; // menos amortecimento (antes 0.90)
const SHIP_VMAX  = 900;  // limite de velocidade

function roundedRectPath(x,y,w,h,r){
  const rr = Math.min(r, w*0.5, h*0.5);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

function drawCard(x,y,w,h,alpha=0.12){
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.fillStyle = `rgba(255,255,255,${alpha})`;
  roundedRectPath(x,y,w,h,12);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();
}

function collide(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

// ===================== Assets (com fallback) =====================
const shipImg = new Image();
shipImg.src = 'barco_sprites.png';
let shipReady = false; shipImg.onload = () => shipReady = true;

const rockImg = new Image();
rockImg.src = 'pedra.png';
let rockReady = false; rockImg.onload = () => rockReady = true;

const logoImg = new Image();
logoImg.src = 'logo.png';
let logoReady = false; logoImg.onload = () => logoReady = true;

const logo2Img = new Image();
logo2Img.src = 'logo2.png';
let logo2Ready = false; logo2Img.onload = () => logo2Ready = true;

// ===================== Estado do jogo =====================
let state = {
  mode: 'menu',
  score: 0,
  shipX: BASE_W / 2,
  shipNum: 1,
  targetNum: 2, // Próximo número a ser coletado nos níveis 3 e 4
  objs: [],
  spawnTimer: 0,
  speed: 1,
  msg: '',
  playerName: ''
};

// ===================== Tabela de Classificação =====================
// Função para carregar a tabela de classificação do localStorage
function loadLeaderboard() {
  const leaderboardData = localStorage.getItem('navioBoardLevel1');
  return leaderboardData ? JSON.parse(leaderboardData) : [];
}

// Função para salvar a tabela de classificação no localStorage
function saveLeaderboard(leaderboard) {
  localStorage.setItem('navioBoardLevel1', JSON.stringify(leaderboard));
}

// Função para adicionar uma nova pontuação à tabela de classificação
function addScoreToLeaderboard(name, score) {
  const leaderboard = loadLeaderboard();
  
  // Adicionar a nova pontuação
  leaderboard.push({ name, score, date: new Date().toLocaleDateString() });
  
  // Ordenar por pontuação (maior para menor)
  leaderboard.sort((a, b) => b.score - a.score);
  
  // Manter apenas as 10 melhores pontuações
  if (leaderboard.length > 10) {
    leaderboard.length = 10;
  }
  
  // Salvar a tabela atualizada
  saveLeaderboard(leaderboard);
  
  return leaderboard;
}
let keys = new Set();
let shipVX = 0;
let level = 1;

// Efeitos
let tGlobal = 0;
let shake = 0;
const wakeParticles = [];
const fxParticles = [];
const MAX_PARTICLES = 220;

// ===================== Controles =====================
// Adicionar evento de clique para os botões
canvas.addEventListener('click', function(e) {
  if (state.mode !== 'menu') return;
  
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const clickX = (e.clientX - rect.left) * scaleX;
  const clickY = (e.clientY - rect.top) * scaleY;
  
  const w = BASE_W, h = BASE_H;
  const cw = Math.min(700, w*0.9), ch = 380;
  const cx = (w - cw)/2, cy = (h - ch)/2;
  
  // Botões para os níveis
  const buttonW = 600, buttonH = 50;
  const buttonX = (w - buttonW) / 2;
  
  // Verificar se clicou em algum botão
  if (clickX >= buttonX && clickX <= buttonX + buttonW) {
    // Botão Nível 1
    if (clickY >= cy + 120 - 25 && clickY <= cy + 120 - 25 + buttonH) {
      console.log("Botão Nível 1 clicado");
      state.mode = 'enterName';
      state.playerName = '';
    }
    // Botão Nível 2
    else if (clickY >= cy + 180 - 25 && clickY <= cy + 180 - 25 + buttonH) {
      startLevel(2);
    }
    // Botão Nível 3
    else if (clickY >= cy + 240 - 25 && clickY <= cy + 240 - 25 + buttonH) {
      startLevel(3);
    }
    // Botão Nível 4
    else if (clickY >= cy + 300 - 25 && clickY <= cy + 300 - 25 + buttonH) {
      startLevel(4);
    }
  }
});

// Função para alternar modo tela cheia
function toggleFullScreen() {
  if (!document.fullscreenElement &&    // método padrão
      !document.mozFullScreenElement && // Firefox
      !document.webkitFullscreenElement && // Chrome, Safari e Opera
      !document.msFullscreenElement) {  // IE/Edge
    // Entrar no modo tela cheia
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.mozRequestFullScreen) { // Firefox
      document.documentElement.mozRequestFullScreen();
    } else if (document.documentElement.webkitRequestFullscreen) { // Chrome, Safari e Opera
      document.documentElement.webkitRequestFullscreen();
    } else if (document.documentElement.msRequestFullscreen) { // IE/Edge
      document.documentElement.msRequestFullscreen();
    }
  } else {
    // Sair do modo tela cheia
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) { // Firefox
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) { // Chrome, Safari e Opera
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { // IE/Edge
      document.msExitFullscreen();
    }
  }
}

window.addEventListener('keydown', e => {
  console.log("Tecla pressionada:", e.key);
  
  // Tecla F para alternar modo tela cheia
  if (e.key === 'f' || e.key === 'F') {
    toggleFullScreen();
    return;
  }
  
  if (e.key === 'Escape') { 
    if (state.mode === 'enterName') {
      state.mode = 'menu';
    } else {
      state.mode = 'menu'; 
      resetGame(); 
    }
  }
  
  if (state.mode === 'menu') {
    if (e.key === '1' || e.key === 'Numpad1' || e.key === 'Digit1') {
      console.log("Tecla 1 pressionada - Mudando para tela de entrada de nome");
      state.mode = 'enterName';
      state.playerName = '';
    }
    else if (e.key === '2' || e.key === 'Numpad2' || e.key === 'Digit2') startLevel(2);
    else if (e.key === '3' || e.key === 'Numpad3' || e.key === 'Digit3') startLevel(3);
    else if (e.key === '4' || e.key === 'Numpad4' || e.key === 'Digit4') startLevel(4);
  }
  
  // Adicionar a tecla ao conjunto de teclas pressionadas
  keys.add(e.key);
});

// Adicionar evento para capturar entrada de texto para o nome
window.addEventListener('keypress', e => {
  if (state.mode === 'enterName') {
    // Se pressionar Enter e o nome não estiver vazio, inicia o jogo
    if (e.key === 'Enter' && state.playerName.trim().length > 0) {
      startLevel(1);
    } 
    // Adiciona caracteres ao nome (limitado a 15 caracteres)
    else if (e.key !== 'Enter' && state.playerName.length < 15) {
      state.playerName += e.key;
    }
  }
});

// Adicionar evento para permitir apagar caracteres do nome
window.addEventListener('keydown', e => {
  if (state.mode === 'enterName' && e.key === 'Backspace') {
    state.playerName = state.playerName.slice(0, -1);
    e.preventDefault(); // Previne que a página volte
  }
});
window.addEventListener('keyup', e => keys.delete(e.key));

// ===================== Fluxo de jogo =====================
function resetGame() {
  state.score = 0;
  state.shipX = BASE_W / 2;
  state.objs = [];
  state.spawnTimer = 0;
  state.speed = 1;
  state.msg = '';
  state.targetNum = 2; // Reiniciar o próximo número alvo
  shipVX = 0;
  shake = 0;
  wakeParticles.length = 0;
  fxParticles.length = 0;
}

function startLevel(lv) {
  resetGame();
  level = lv;
  if (level === 1) state.mode = 'level1';
  if (level === 2) { 
    state.mode = 'level2'; 
    // Set a random number between 1 and 10 for the boat
    state.shipNum = Math.floor(Math.random() * 10) + 1;
  }
  if (level === 3) { 
    state.mode = 'level3'; 
    // Começar com -10 e ir subindo até 5 em sequência
    state.shipNum = -10; 
    state.targetNum = -9; // Próximo número a ser coletado
  }
  if (level === 4) { 
    state.mode = 'level4'; 
    state.shipNum = 1; 
    state.targetNum = 2; // Próximo número a ser coletado
  }
}

function gameOver(msg) {
  // Se for o nível 1, salvar a pontuação na tabela de classificação
  if (level === 1 && state.playerName && state.playerName.trim().length > 0) {
    addScoreToLeaderboard(state.playerName, state.score);
    state.mode = 'leaderboard';
  } else {
    state.mode = 'gameover';
  }
  
  state.msg = msg || 'Game Over';
  shake = 10;
}

// ===================== Spawners =====================
function spawnRock() {
  state.objs.push({
    type: 'rock',
    x: rand(40, BASE_W-40),
    y: -40,
    vy: rand(100,180),
    rot: rand(-0.2,0.2)
  });
}

function spawnNumber() {
  let val;
  
  if (level === 4) {
    // Para o nível 4, aumentar a chance de gerar o próximo número na sequência
    if (Math.random() < 0.5) {
      val = state.targetNum; // 50% de chance de ser o número alvo
      console.log(`Gerando número alvo: ${val} para nível 4`);
    } else {
      // 50% de chance de ser um número aleatório entre 1 e 10
      do {
        val = Math.floor(Math.random() * 10) + 1;
      } while (val === state.targetNum);
      console.log(`Gerando número aleatório: ${val} para nível 4`);
    }
  } else if (level === 3) {
    // Para o nível 3, aumentar a chance de gerar o próximo número na sequência
    if (Math.random() < 0.5) {
      val = state.targetNum; // 50% de chance de ser o número alvo
      console.log(`Gerando número alvo: ${val} para nível 3`);
    } else {
      // 50% de chance de ser um número aleatório entre -10 e 5
      do {
        val = Math.floor(Math.random() * 16) - 10;
      } while (val === state.targetNum);
    }
  } else if (level === 2) {
    // Para o nível 2, aumentar a chance de gerar o número do barco
    if (Math.random() < 0.3) {
      val = state.shipNum; // 30% de chance de ser o número do barco
    } else {
      // 70% de chance de ser um número aleatório entre 1 e 10, mas não o número do barco
      do {
        val = Math.floor(Math.random() * 10) + 1;
      } while (val === state.shipNum);
    }
  }
  
  state.objs.push({
    type: 'num',
    x: rand(40, BASE_W-40),
    y: -40,
    vy: rand(100,160),
    val,
    rot: rand(-0.15,0.15)
  });
}

// ===================== Partículas =====================
function addWakeParticle(x, y) {
  if (wakeParticles.length > MAX_PARTICLES) wakeParticles.shift();
  wakeParticles.push({
    x, y,
    r: rand(2,4),
    vx: rand(-20,20),
    vy: rand(40,90),
    life: rand(0.6,1.0),
    alpha: 1
  });
}

function addConfetti(x, y, colorA, colorB) {
  const n = 20;
  for (let i=0;i<n;i++){
    if (fxParticles.length > MAX_PARTICLES) fxParticles.shift();
    fxParticles.push({
      x, y,
      r: rand(2,4),
      vx: rand(-160,160),
      vy: rand(-220, -80),
      g: rand(320, 520),
      rot: rand(0, Math.PI*2),
      vr: rand(-6,6),
      color: Math.random()<0.5?colorA:colorB,
      life: rand(0.6,1.0),
      alpha: 1
    });
  }
}

// ===================== Background (ondas) =====================
function drawBackground(dt, w, h) {
  const skyGrad = ctx.createLinearGradient(0,0,0,h*0.6);
  skyGrad.addColorStop(0, '#102041');
  skyGrad.addColorStop(0.7, '#0d1730');
  skyGrad.addColorStop(1, '#0b1226');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0,0,w,h);

  const glowY = h*0.55 + Math.sin(tGlobal*0.4)*6;
  const glowGrad = ctx.createRadialGradient(w*0.5, glowY, 10, w*0.5, glowY, w*0.6);
  glowGrad.addColorStop(0, 'rgba(255,255,255,0.08)');
  glowGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = glowGrad;
  ctx.fillRect(0,0,w,h);

  const waterTop = h*0.35;
  const waterGrad = ctx.createLinearGradient(0, waterTop, 0, h);
  waterGrad.addColorStop(0, '#143a64');
  waterGrad.addColorStop(1, '#0b2746');
  ctx.fillStyle = waterGrad;
  ctx.fillRect(0, waterTop, w, h-waterTop);

  ctx.save();
  ctx.globalAlpha = 0.4;
  for (let layer=0; layer<3; layer++){
    const amp = 8 + layer*5;
    const freq = 0.012 + layer*0.004;
    const speed = 16 + layer*10;
    const yBase = waterTop + 20 + layer*18 + Math.sin(tGlobal*0.6 + layer)*4;
    ctx.beginPath();
    ctx.moveTo(0, yBase);
    for (let x=0; x<=w; x+=6){
      const y = yBase + Math.sin((x*freq) + (tGlobal*speed*0.05)) * amp;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.lineTo(0, h);
    ctx.closePath();
    const g = ctx.createLinearGradient(0, yBase-amp, 0, h);
    g.addColorStop(0, 'rgba(255,255,255,0.10)');
    g.addColorStop(1, 'rgba(255,255,255,0.00)');
    ctx.fillStyle = g;
    ctx.fill();
  }
  ctx.restore();
}

// ===================== Loop =====================
let last = performance.now();
function loop(t) {
  const dt = Math.min(0.033, (t - last)/1000);
  last = t;
  tGlobal += dt;

  update(dt);
  render(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ===================== Update =====================
function update(dt) {
  const w = BASE_W, h = BASE_H;

  if (state.mode.startsWith('level')) {
    // Movimento do navio (MAIS RÁPIDO)
    if (keys.has('ArrowLeft')) {
      shipVX -= SHIP_ACCEL * dt;
      console.log("Tecla esquerda pressionada, shipVX =", shipVX);
    }
    if (keys.has('ArrowRight')) {
      shipVX += SHIP_ACCEL * dt;
      console.log("Tecla direita pressionada, shipVX =", shipVX);
    }
    shipVX *= SHIP_DAMP;
    shipVX = clamp(shipVX, -SHIP_VMAX, SHIP_VMAX);

    state.shipX += shipVX * dt;
    state.shipX = clamp(state.shipX, 40, w-40);
    
    // Debug
    if (Math.abs(shipVX) > 0.1) {
      console.log("Barco movendo: shipVX =", shipVX, "shipX =", state.shipX);
    }

    // Spawn
    state.spawnTimer += dt;
    const interval = 1 / state.speed;
    if (state.spawnTimer > interval) {
      state.spawnTimer = 0;
      if (level === 1) spawnRock();
      else spawnNumber();
    }

    // Dificuldade
    state.speed += dt * 0.08;

    // Partículas de rastro
    if (Math.abs(shipVX) > 5 || Math.random() < 0.5) {
      addWakeParticle(state.shipX + rand(-14,14), h-68 + rand(-2,6));
    }

    // Atualizar objetos
    for (let i = state.objs.length-1; i>=0; i--) {
      const o = state.objs[i];
      o.y += o.vy * dt * state.speed;
      if (o.type==='rock') {
        if (collide(state.shipX-20, h-100, 40, 40, o.x-22, o.y-22, 44, 44)) {
          addConfetti(o.x, o.y, 'rgba(255,255,255,0.9)', 'rgba(255,80,90,0.9)');
          gameOver('Bateu na pedra!');
        }
      }
      if (o.type==='num') {
        if (collide(state.shipX-20, h-100, 40, 40, o.x-22, o.y-22, 44, 44)) {
          if (level === 2) {
            // Level 2: Only collect the number that matches the boat's number
            if (o.val === state.shipNum) {
              state.score += 10;
              addConfetti(o.x, o.y, '#ffe58a', '#ffb84d');
              state.mode = 'win';
              state.msg = 'Você venceu!';
            } else {
              addConfetti(o.x, o.y, '#ff7585', '#ff3b57');
              gameOver('Número errado!');
            }
          } else if ((level === 3 || level === 4) && o.val === state.targetNum) {
            // Levels 3 and 4: Collect numbers in sequence
            state.shipNum = o.val;
            state.score += 5;
            const isPos = o.val >= 0;
            addConfetti(o.x, o.y, isPos ? '#ffe58a' : '#8ec5ff', isPos ? '#ffb84d' : '#5a8bff');
            
            // Atualizar o próximo número alvo
            state.targetNum = state.shipNum + 1;
            
            // Verificar se o jogador venceu
            if ((level===4 && state.shipNum>=10) || (level===3 && state.shipNum>=5)) {
              state.mode = 'win';
              state.msg = 'Você venceu!';
            }
          } else {
            // Número errado
            addConfetti(o.x, o.y, '#ff7585', '#ff3b57');
            if (level === 3 || level === 4) {
              gameOver(`Número errado! Você precisava pegar o ${state.targetNum}`);
            } else {
              addConfetti(o.x, o.y, '#ff7585', '#ff3b57');
              gameOver('Pegou número menor!');
            }
          }
          state.objs.splice(i,1);
          continue;
        }
      }
      if (o.y > h + 60) {
        if (o.type==='rock' && level===1) state.score++;
        state.objs.splice(i,1);
      }
    }
  }

  // Atualizar partículas
  for (let i=wakeParticles.length-1; i>=0; i--){
    const p = wakeParticles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.alpha -= dt / p.life;
    p.vx *= 0.98;
    if (p.alpha <= 0) wakeParticles.splice(i,1);
  }
  for (let i=fxParticles.length-1; i>=0; i--){
    const p = fxParticles[i];
    p.vy += p.g * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.rot += p.vr * dt;
    p.alpha -= dt / p.life;
    if (p.alpha <= 0 || p.y > BASE_H + 100) fxParticles.splice(i,1);
  }

  shake = Math.max(0, shake - dt*12);
}

// ===================== Render =====================
function render(dt) {
  const w = BASE_W, h = BASE_H;

  ctx.save();

  drawBackground(dt, w, h);

  const sx = (Math.random() * 2 - 1) * shake;
  const sy = (Math.random() * 2 - 1) * shake;
  ctx.translate(sx, sy);

  if (state.mode==='menu') {
    drawMenu(w, h);
    ctx.restore();
    drawOverlayFrame(w, h);
    return;
  }
  
  if (state.mode==='enterName') {
    drawEnterNameScreen(w, h);
    ctx.restore();
    drawOverlayFrame(w, h);
    return;
  }
  
  if (state.mode==='leaderboard') {
    drawLeaderboardScreen(w, h);
    ctx.restore();
    drawOverlayFrame(w, h);
    return;
  }

  for (const o of state.objs) {
    if (o.type==='rock') {
      drawRock(o);
    } else if (o.type==='num') {
      drawNumBox(o);
    }
  }

  drawShip(w, h);

  drawWake();
  drawFX();

  drawHUD();

  if (state.mode==='gameover' || state.mode==='win') {
    drawEndScreen(w, h, state.msg);
  }

  ctx.restore();
  drawOverlayFrame(w, h);
}

// ===================== Desenho de elementos =====================
function drawMenu(w, h) {
  const title = 'Jogo do Navio';
  const sub = 'Use ← → para mover | ESC para voltar | F para tela cheia';
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const cw = Math.min(700, w*0.9), ch = 380; // Altura aumentada para acomodar os botões
  const cx = (w - cw)/2, cy = (h - ch)/2;
  drawCard(cx, cy, cw, ch, 0.14);

  const grad = ctx.createLinearGradient(0, cy, 0, cy+ch);
  grad.addColorStop(0, '#9be8df');
  grad.addColorStop(1, '#53d0c5');
  ctx.fillStyle = grad;
  ctx.strokeStyle = 'rgba(0,0,0,0.35)';
  ctx.lineWidth = 6;

  // Draw logos next to the title with more spacing
  if (logoReady) {
    ctx.drawImage(logoImg, cx + 50, cy + 50, 60, 60);
  }
  
  if (logo2Ready) {
    ctx.drawImage(logo2Img, cx + cw - 110, cy + 50, 60, 60);
  }

  ctx.font = '900 56px Poppins, Arial';
  ctx.strokeText(title, w/2, cy + 80);
  ctx.fillText(title, w/2, cy + 80);

  ctx.font = '600 22px Poppins, Arial';
  ctx.fillStyle = '#e8eefc';
  
  // Botões para os níveis
  const buttonW = 600, buttonH = 50;
  const buttonX = (w - buttonW) / 2;
  
  // Botão Nível 1
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  roundedRectPath(buttonX, cy + 120 - 25, buttonW, buttonH, 10);
  ctx.fill();
  
  ctx.fillStyle = '#e8eefc';
  ctx.fillText('Pressione 1 para Nível 1 (Desvie das pedras)', w/2, cy + 120);
  
  // Botão Nível 2
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  roundedRectPath(buttonX, cy + 180 - 25, buttonW, buttonH, 10);
  ctx.fill();
  
  ctx.fillStyle = '#e8eefc';
  ctx.fillText('Pressione 2 para Nível 2 (Colete apenas o seu número)', w/2, cy + 180);
  
  // Botão Nível 3
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  roundedRectPath(buttonX, cy + 240 - 25, buttonW, buttonH, 10);
  ctx.fill();
  
  ctx.fillStyle = '#e8eefc';
  ctx.fillText('Pressione 3 para Nível 3 (Colete números -10 até 5 em sequência)', w/2, cy + 240);
  
  // Botão Nível 4
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  roundedRectPath(buttonX, cy + 300 - 25, buttonW, buttonH, 10);
  ctx.fill();
  
  ctx.fillStyle = '#e8eefc';
  ctx.fillText('Pressione 4 para Nível 4 (Colete números 1 até 10 em sequência)', w/2, cy + 300);

  ctx.font = '500 16px Poppins, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.fillText(sub, w/2, cy + ch - 20);
  
  // Credit message in bottom left corner
  ctx.textAlign = 'left';
  ctx.font = '400 12px Poppins, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillText('Feito por Lucas Martins e João Carlos do 3º02 da Maura Abaurre.', 20, h - 20);
  ctx.restore();
}

function drawHUD() {
  ctx.save();
  const pad = 14;
  const cardW = 280, cardH = 74;
  drawCard(18, 18, cardW, cardH, 0.14);

  ctx.fillStyle = '#ffffff';
  ctx.textBaseline = 'top';
  ctx.font = '700 20px Poppins, Arial';
  ctx.fillText(`Score: ${state.score}`, 18+pad, 18+pad);
  ctx.font = '600 16px Poppins, Arial';
  
  // Update level text to include level 4
  let lvlText;
  if (state.mode === 'level1') lvlText = 'Nível 1';
  else if (state.mode === 'level2') lvlText = 'Nível 2';
  else if (state.mode === 'level3') lvlText = 'Nível 3';
  else if (state.mode === 'level4') lvlText = 'Nível 4';
  
  ctx.fillText(lvlText, 18+pad, 18+pad+28);

  if (level > 1) {
    // Create a separate card for the target number
    const targetCardW = 140, targetCardH = 74;
    drawCard(cardW + 40, 18, targetCardW, targetCardH, 0.14);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '600 16px Poppins, Arial';
    
    if (level === 2) {
      // Nível 2: Mostrar o número que o barco deve coletar
      ctx.fillText(`Procure:`, cardW + 40 + pad, 18+pad);
      
      ctx.font = '700 32px Poppins, Arial';
      ctx.fillText(`${state.shipNum}`, cardW + 40 + pad + 30, 18+pad+32);
    } 
    else if (level === 3 || level === 4) {
      // Níveis 3 e 4: Mostrar o próximo número na sequência
      ctx.fillText(`Próximo:`, cardW + 40 + pad, 18+pad);
      
      ctx.font = '700 32px Poppins, Arial';
      ctx.fillText(`${state.targetNum}`, cardW + 40 + pad + 30, 18+pad+32);
      
      // Mostrar o número atual e o objetivo
      const progressCardW = 180, progressCardH = 74;
      drawCard(cardW + 40 + targetCardW + 20, 18, progressCardW, progressCardH, 0.14);
      
      ctx.fillStyle = '#ffffff';
      ctx.font = '600 16px Poppins, Arial';
      ctx.fillText(`Progresso:`, cardW + 40 + targetCardW + 20 + pad, 18+pad);
      
      ctx.font = '700 20px Poppins, Arial';
      if (level === 3) {
        ctx.fillText(`${state.shipNum} → 5`, cardW + 40 + targetCardW + 20 + pad + 30, 18+pad+32);
      } else {
        ctx.fillText(`${state.shipNum} → 10`, cardW + 40 + targetCardW + 20 + pad + 30, 18+pad+32);
      }
    }
    // Definir número atual de forma segura para evitar erro de referência
    const num = (level === 2) ? state.shipNum : state.targetNum;
    const g = ctx.createLinearGradient(0,0,0,40);
    if (num >= 0) { g.addColorStop(0, '#ffe58a'); g.addColorStop(1, '#ffb84d'); }
    else { g.addColorStop(0, '#8ec5ff'); g.addColorStop(1, '#5a8bff'); }
    ctx.fillStyle = g;
    ctx.font = '700 20px Poppins, Arial';
    ctx.fillText(`Número: ${num}`, 18+pad+120, 18+pad+28);
  }
  ctx.restore();
}

function drawEndScreen(w, h, msg) {
  ctx.save();
  const cw = Math.min(560, w*0.9), ch = 200;
  const cx = (w - cw)/2, cy = (h - ch)/2;
  drawCard(cx, cy, cw, ch, 0.18);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = '900 42px Poppins, Arial';
  ctx.fillStyle = state.mode==='win' ? '#7af0d8' : '#ff8fa0';
  ctx.fillText(msg, w/2, cy+70);

  ctx.font = '600 18px Poppins, Arial';
  ctx.fillStyle = '#eaf0ff';
  ctx.fillText('Pressione ESC para voltar ao menu', w/2, cy+120);
  ctx.restore();
}

function drawOverlayFrame(w, h) {
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0, 'rgba(255,255,255,0.10)');
  g.addColorStop(1, 'rgba(255,255,255,0.02)');
  ctx.strokeStyle = g;
  ctx.lineWidth = 2;
  roundedRectPath(2,2,w-4,h-4,16);
  ctx.stroke();
}

function drawRock(o) {
  ctx.save();
  ctx.translate(o.x, o.y);
  ctx.rotate(o.rot);

  if (rockReady) {
    ctx.drawImage(rockImg, -24, -24, 48, 48);
  } else {
    const g = ctx.createLinearGradient(-24,-24, 24,24);
    g.addColorStop(0, '#7d7d7d');
    g.addColorStop(1, '#505050');
    ctx.fillStyle = g;
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-18,-12);
    ctx.lineTo(-8,-20);
    ctx.lineTo(10,-18);
    ctx.lineTo(20,-6);
    ctx.lineTo(14,10);
    ctx.lineTo(-6,18);
    ctx.lineTo(-22,4);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath();
    ctx.ellipse(-4,-8,12,6,0,0,Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

function drawNumBox(o) {
  ctx.save();
  ctx.translate(o.x, o.y);
  ctx.rotate(o.rot);

  const size = 40;
  ctx.shadowColor = 'rgba(0,0,0,0.4)';
  ctx.shadowBlur = 10;
  const g = ctx.createLinearGradient(0,-size,0,size);
  if (o.val >= 0) { g.addColorStop(0, '#ffe58a'); g.addColorStop(1, '#ffb84d'); }
  else { g.addColorStop(0, '#8ec5ff'); g.addColorStop(1, '#5a8bff'); }
  ctx.fillStyle = g;
  roundedRectPath(-size/2, -size/2, size, size, 10);
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.fillStyle = '#111';
  ctx.font = '700 20px Poppins, Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(o.val, 0, 1);
  ctx.restore();
}

function drawShip(w, h) {
  ctx.save();
  const bob = Math.sin(tGlobal*6 + shipVX*0.02) * 2;
  const frame = shipVX < -20 ? 0 : (shipVX > 20 ? 2 : 1);
  const sx = state.shipX - 32, sy = h - 102 + bob;

  ctx.globalAlpha = 0.25;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(state.shipX, h-60, 26, 10, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;

  if (shipReady) {
    ctx.drawImage(shipImg, frame*64, 0, 64, 64, sx, sy, 64, 64);
  } else {
    ctx.save();
    ctx.translate(state.shipX, h-70 + bob);
    ctx.rotate(shipVX * 0.0008);
    const hull = ctx.createLinearGradient(-30,-20,30,20);
    hull.addColorStop(0, '#9be0d7');
    hull.addColorStop(1, '#58c7bc');
    ctx.fillStyle = hull;
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-30,10);
    ctx.lineTo(30,10);
    ctx.quadraticCurveTo(18,22,0,28);
    ctx.quadraticCurveTo(-18,22,-30,10);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#ffffff';
    roundedRectPath(-12, -10, 24, 18, 4);
    ctx.fill();
    ctx.restore();
  }

  if (Math.random() < 0.4) addWakeParticle(state.shipX + rand(-10,10), h-64 + rand(-4,4));
  ctx.restore();
}

function drawWake() {
  ctx.save();
  for (const p of wakeParticles) {
    ctx.globalAlpha = Math.max(0, p.alpha) * 0.7;
    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r*2);
    g.addColorStop(0, 'rgba(255,255,255,0.7)');
    g.addColorStop(1, 'rgba(255,255,255,0.0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r*2, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

function drawFX() {
  ctx.save();
  for (const p of fxParticles) {
    ctx.globalAlpha = Math.max(0, p.alpha);
    ctx.fillStyle = p.color;
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rot);
    roundedRectPath(-p.r, -p.r, p.r*2, p.r*2, 2);
    ctx.fill();
    ctx.restore();
  }
  ctx.restore();
}

function drawEnterNameScreen(w, h) {
  const title = 'Digite seu nome';
  const sub = 'Pressione ENTER para jogar | ESC para voltar';
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const cw = Math.min(680, w*0.9), ch = 280;
  const cx = (w - cw)/2, cy = (h - ch)/2;
  drawCard(cx, cy, cw, ch, 0.14);

  const grad = ctx.createLinearGradient(0, cy, 0, cy+ch);
  grad.addColorStop(0, '#9be8df');
  grad.addColorStop(1, '#53d0c5');
  ctx.fillStyle = grad;
  ctx.strokeStyle = 'rgba(0,0,0,0.35)';
  ctx.lineWidth = 6;

  ctx.font = '900 48px Poppins, Arial';
  ctx.strokeText(title, w/2, cy + 80);
  ctx.fillText(title, w/2, cy + 80);

  // Campo de entrada de nome
  const inputW = 300, inputH = 50;
  const inputX = (w - inputW) / 2;
  const inputY = cy + 140;
  
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.lineWidth = 2;
  roundedRectPath(inputX, inputY, inputW, inputH, 8);
  ctx.fill();
  ctx.stroke();
  
  // Texto do nome
  ctx.fillStyle = '#333';
  ctx.font = '600 24px Poppins, Arial';
  ctx.textAlign = 'left';
  ctx.fillText(state.playerName + (Math.floor(Date.now()/500) % 2 === 0 ? '|' : ''), inputX + 10, inputY + inputH/2);
  
  // Instruções
  ctx.textAlign = 'center';
  ctx.font = '500 16px Poppins, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.fillText(sub, w/2, cy + ch - 20);
  ctx.restore();
}

function drawLeaderboardScreen(w, h) {
  const title = 'Tabela de Classificação';
  const sub = 'Pressione ESC para voltar ao menu';
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const cw = Math.min(680, w*0.9), ch = 400; // Maior altura para a tabela
  const cx = (w - cw)/2, cy = (h - ch)/2;
  drawCard(cx, cy, cw, ch, 0.14);

  const grad = ctx.createLinearGradient(0, cy, 0, cy+ch);
  grad.addColorStop(0, '#9be8df');
  grad.addColorStop(1, '#53d0c5');
  ctx.fillStyle = grad;
  ctx.strokeStyle = 'rgba(0,0,0,0.35)';
  ctx.lineWidth = 6;

  ctx.font = '900 48px Poppins, Arial';
  ctx.strokeText(title, w/2, cy + 60);
  ctx.fillText(title, w/2, cy + 60);

  // Sua pontuação atual
  ctx.font = '700 24px Poppins, Arial';
  ctx.fillStyle = '#fff';
  ctx.fillText(`Sua pontuação: ${state.score}`, w/2, cy + 110);
  
  // Carregar a tabela de classificação
  const leaderboard = loadLeaderboard();
  
  // Desenhar a tabela
  const tableW = cw - 80;
  const tableX = cx + 40;
  const tableY = cy + 140;
  const rowH = 30;
  
  // Cabeçalho da tabela
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  roundedRectPath(tableX, tableY, tableW, rowH, 8);
  ctx.fill();
  
  ctx.fillStyle = '#333';
  ctx.font = '700 18px Poppins, Arial';
  ctx.textAlign = 'left';
  ctx.fillText('Pos.', tableX + 20, tableY + rowH/2);
  ctx.fillText('Nome', tableX + 80, tableY + rowH/2);
  ctx.textAlign = 'right';
  ctx.fillText('Pontuação', tableX + tableW - 140, tableY + rowH/2);
  ctx.fillText('Data', tableX + tableW - 20, tableY + rowH/2);
  
  // Linhas da tabela
  for (let i = 0; i < Math.min(leaderboard.length, 8); i++) {
    const entry = leaderboard[i];
    const rowY = tableY + rowH * (i + 1) + 5;
    
    // Destacar a linha do jogador atual
    if (entry.name === state.playerName && entry.score === state.score) {
      ctx.fillStyle = 'rgba(255,255,100,0.3)';
      roundedRectPath(tableX, rowY, tableW, rowH, 4);
      ctx.fill();
    }
    
    ctx.fillStyle = '#fff';
    ctx.font = '600 16px Poppins, Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`${i+1}.`, tableX + 20, rowY + rowH/2);
    ctx.fillText(entry.name, tableX + 80, rowY + rowH/2);
    ctx.textAlign = 'right';
    ctx.fillText(`${entry.score}`, tableX + tableW - 140, rowY + rowH/2);
    ctx.fillText(entry.date, tableX + tableW - 20, rowY + rowH/2);
  }
  
  // Instruções
  ctx.textAlign = 'center';
  ctx.font = '500 16px Poppins, Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.fillText(sub, w/2, cy + ch - 20);
  ctx.restore();
}

// O jogo já tem um loop de jogo definido acima, não precisamos de outro
</script>
</body>
</html>
